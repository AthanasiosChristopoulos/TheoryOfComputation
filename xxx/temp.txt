%{

    #include <stdio.h>
    #include <string.h>
    #include "cgen.h"
    #include <ctype.h>
    #include <stdbool.h>
    #include <stdlib.h>
    #include <regex.h>


    #define MAX_FUNCTIONS 100
    #define MAX_LINE_LENGTH 1024
    #define MAX_LINES 1000
    #define BUFFER_SIZE 1024  
    #define MAX_FUNCTIONS 100
    #define MAX_NAME_LENGTH 50

    extern int yydebug;
    extern int parse_error;
    extern int yylex(void); // use the lexer, lex.yy.cc has already been generated
    extern int line_num;
    extern void add_macro(const char *id, const char *value);

    void print_evaluation(char* result);
    int match_return_variable_type(char* result);
    bool is_integer(const char* str);

    int used_lambdalib_function = 0;
    char *included_functionnames[MAX_FUNCTIONS];
    int num_of_included_functions = 0;

    char *lines[MAX_LINES];
    int current_line_index = 0;

    int for_has_step = 0;
    char* function_name_temp;
    int first_variable = 1;

//==========================================================================================================================

void store_line(const char *text) {
  
    if (current_line_index < MAX_LINES) {

        char temp[BUFFER_SIZE];
        strncpy(temp, text, BUFFER_SIZE - 1);
        temp[BUFFER_SIZE - 1] = '\0'; 

        char *newline_pos = strchr(temp, '\n');
        if (newline_pos) {
            *newline_pos = '\0';
        }

        lines[current_line_index] = strdup(temp);
        current_line_index++;
    }
}

  void free_lines() {
      for (int i = 0; i < current_line_index; i++) {
          free(lines[i]);
      }
  }

 int main_has_been_defined = 0;

//==========================================================================================================================    

int func_needs_return_type = 0; 
int body_has_return_type = 0;

int num_of_args_in_function = 0; 
int num_of_args_in_function_in_func_call = 0;

typedef struct {
    const char* name;
    int has_arguments;

} DefinedFunction;

DefinedFunction *functions = NULL;
size_t num_functions = 0;

//=========================================================================================================================

void add_function(const char *name, int has_arguments) {

    functions = realloc(functions, (num_functions + 1) * sizeof(DefinedFunction));
    if (!functions) {
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }

    DefinedFunction *new_func = &functions[num_functions];
    new_func->name = strdup(name);  
    new_func->has_arguments = has_arguments;
    num_functions++;
}

//=========================================================================================================================

int find_included_function(const char *functionname) {

    for (int i = 0; i < num_of_included_functions; i++) {
        if (strcmp(included_functionnames[i], functionname) == 0) {
            return 1; 
        }

    }
    return 0; 
}

//=========================================================================================================================
//=========================================================================================================================
// Include Functions in lambdalib.h

int count_args(const char *line) {
    int count = 0;
    const char *p = strchr(line, '(');
    
    if (p) {
        p++;  
        while (*p == ' ' || *p == '\t') {p++;}
        if (strstr(p, "...")) {
            return 99; 
        }
        if (*p == ')') { return 0; }
        while (*p != ')' && *p != '\0') {
            if (*p == ',') {
                count++;
            }
            p++;
        } 
        count++;
    }
    return count;
}

//=========================================================================================================================

int is_function_definition(const char *line, char *func_name) {
    regex_t regex;
    regmatch_t matches[2];
    const char *pattern = "^(\\s*(void|int|float|char|double|long|short|unsigned|signed|bool|_Bool|\\w+\\*?\\s+)+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\([^)]*\\)\\s*\\{)|^\\s*#define\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\([^)]*\\)\\s*[^\\{]*$";
    
    if (regcomp(&regex, pattern, REG_EXTENDED) != 0) {
        return 0;
    }
    
    int result = regexec(&regex, line, 1, matches, 0); // If a match is found, matches[0] contains the start and end positions.
    regfree(&regex);
    
    if (result == 0) { // Extract the Function Name
        int start = matches[0].rm_so;
        int end = matches[0].rm_eo - 1; // Ignore '('
        strncpy(func_name, line + start, end - start);
        func_name[end - start] = '\0';
        return 1;
    }
    return 0;
}


//=========================================================================================================================
//=========================================================================================================================
//=========================================================================================================================

void extractFunctionName(const char *func_name, char *output) {

    const char *start = func_name;
    while (!isspace(*start) && *start != '\0') {
        start++; 
    }
    while (isspace(*start)) {
        start++; 
    }
    
    int i = 0;
    while (*start != '(' && *start != '\0' && i < 99) {
        output[i++] = *start++;
    }
    output[i] = '\0';
}

//=========================================================================================================================

void extractFunctionNames(const char *code, char function_names[MAX_FUNCTIONS][MAX_NAME_LENGTH], int *count) {

    const char *ptr = code;
    *count = 0;

    while (*ptr != '\0') {  
        ptr = strstr(ptr, "double ");
        if (ptr != NULL) {
            ptr += 6;
        } else {
            ptr = strstr(ptr, "void ");
            if (ptr != NULL) {
                ptr += 4; 
            }
        }
        while (*ptr && isspace(*ptr)) {
            ptr++;
        }
        char name[MAX_NAME_LENGTH] = {0};
        int i = 0;

        while (*ptr && (isalnum(*ptr) || *ptr == '_')) { 
            name[i++] = *ptr++;
            if (i >= MAX_NAME_LENGTH - 1) break;  
        }
        name[i] = '\0';
        if (i > 0 && *count < MAX_FUNCTIONS) {
            strcpy(function_names[*count], name);
            (*count)++;
        }
    }
}

//=========================================================================================================================

void include_functions()  {

    FILE *file = fopen("lambdalib.h", "r");
    if (!file) {
        perror("Error opening file");
        return;
    }
    char line[MAX_LINES];

    while (fgets(line, MAX_LINES, file)) {
        char func_name[100];
        char output[100];

        if (is_function_definition(line, func_name)) {
            extractFunctionName(func_name, output);
            strcpy(func_name, output);
            
            int num_args = count_args(line);
            add_function(func_name, num_args);
            included_functionnames[num_of_included_functions] = strdup(func_name);
            num_of_included_functions++;
        }
    }
    fclose(file);
    return;
}

//=========================================================================================================================

const DefinedFunction* find_function(const char* name) {

    for (size_t i = 0; i < num_functions; i++) {
        if (strcmp(functions[i].name, name) == 0) {
            return &functions[i];
        }
    }
    return NULL; 
}

void free_functions() {
    for (size_t i = 0; i < num_functions; i++) {
        free((void*)functions[i].name);
    }
    free(functions);
}

//=========================================================================================================================
//=========================================================================================================================
//=========================================================================================================================
// comp_upper:

int inside_comp= 0;

#define MAX_FUNCTIONS 100

typedef struct FunctionNode {
    char *function_comp;
    char *function_name;
    struct FunctionNode *next;
} FunctionNode;

typedef struct VariableNode {
    char *variable_name;
    struct VariableNode *next;
} VariableNode;

typedef struct CompFunctionMap {

    char *comp_name;
    FunctionNode *functions;  
    VariableNode *variables;
    struct CompFunctionMap *next;

} CompFunctionMap;

#define HASH_TABLE_SIZE 100

CompFunctionMap *compFunctionTable[HASH_TABLE_SIZE] = { NULL };

//=========================================================================================================================

unsigned int hash(const char *str) {
    unsigned int hash = 0;
    while (*str) hash = (hash * 31) + *str++;
    return hash % HASH_TABLE_SIZE;
}

void createNewComp(const char *comp_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *entry = compFunctionTable[index];
    entry = (CompFunctionMap *)malloc(sizeof(CompFunctionMap));
    entry->comp_name = strdup(comp_name);
    entry->functions = NULL;  
    entry->variables = NULL; 
    entry->next = compFunctionTable[index];
    compFunctionTable[index] = entry;
}

int is_comp_type(const char *comp_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *entry = compFunctionTable[index];
    while (entry) {
        if (strcmp(entry->comp_name, comp_name) == 0) {
            return 1;
        }
        entry = entry->next;
    }
    return 0;
}
//=========================================================================================================================
// variable_comp_upper:

void add_comp_variable(const char *comp_name, const char *variable_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *comp = compFunctionTable[index];
    VariableNode *var = comp->variables;

    if(first_variable == 0){
        while (var) {
            if (strcmp(var->variable_name, variable_name) == 0) {
                return; // Variable already exists
            }
            var = var->next;
        }
        first_variable = 0;
    }
    var = (VariableNode *)malloc(sizeof(VariableNode));
    var->variable_name = strdup(variable_name);
    var->next = comp->variables;
    comp->variables = var;
}

void add_comp_variables(const char* comp_name, const char *input) {
    char buffer[256];  
    strncpy(buffer, input, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';
    char *token = strtok(buffer, ",");
    while (token != NULL) {
        while (*token == ' ') token++;
        add_comp_variable(comp_name,token);
        token = strtok(NULL, ",");
    }
}

int is_comp_variable(const char *comp_name, const char *variable_name) {

    unsigned int index = hash(comp_name);
    CompFunctionMap *comp = compFunctionTable[index];

    VariableNode *var = comp->variables;
    
    while (var) {
        // printf("%s\n", var->variable_name);
        if (strcmp(var->variable_name, variable_name) == 0) {
            return 1; // Found
        }
        var = var->next;
    }
    return 0; // Not found
}
//=========================================================================================================================
// function_comp_upper:

void addFunctionToComp(const char *comp_name, const char *function_follow_comp, const char *func_name) {

    unsigned int index = hash(comp_name);

    CompFunctionMap *entry = compFunctionTable[index];
    while (entry) {
        if (strcmp(entry->comp_name, comp_name) == 0) {
            FunctionNode *newNode = (FunctionNode *)malloc(sizeof(FunctionNode));
            newNode->function_comp = strdup(function_follow_comp);
            newNode->function_name = strdup(func_name); 
            newNode->next = entry->functions;
            entry->functions = newNode;
            return;
        }
        entry = entry->next;
    }
}
//=========================================================================================================================

int is_comp_function(const char *comp_name, const char *function_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *entry = compFunctionTable[index];

    while (entry) {
        if (strcmp(entry->comp_name, comp_name) == 0) {
            FunctionNode *function_current = entry->functions;
            while (function_current) {
                if (strcmp(function_current->function_name, function_name) == 0) {
                    return 1; // Function found
                }
                function_current = function_current->next;
            }
            return 0; 
        }
        entry = entry->next;
    }

    return 0;
}
//=========================================================================================================================

char *getCompFunctionsAsString(const char *comp_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *entry = compFunctionTable[index];

    while (entry) {
        if (strcmp(entry->comp_name, comp_name) == 0) {
            size_t totalSize = 1;
            FunctionNode *fn = entry->functions;
            while (fn) {
                totalSize += strlen(fn->function_comp) + 2; 
                fn = fn->next;
            }
            char *result = (char *)malloc(totalSize);
            if (!result) {
                perror("Memory allocation failed");
                exit(EXIT_FAILURE);
            }
            result[0] = '\0'; 

            fn = entry->functions;
            while (fn) {
                strcat(result, fn->function_comp);
                strcat(result, "\n"); 
                fn = fn->next;
            }
            return result; 
        }
        entry = entry->next;
    }

    return strdup("");
}

//=========================================================================================================================

char *getCompFunctionNamesAsString(const char *comp_name) {
    unsigned int index = hash(comp_name);
    CompFunctionMap *entry = compFunctionTable[index];

    while (entry) {
        if (strcmp(entry->comp_name, comp_name) == 0) {
            size_t totalSize = 1; 
            FunctionNode *fn = entry->functions;
            while (fn) {
                totalSize += strlen(fn->function_name) * 2 + 6; 
                fn = fn->next;
            }
            char *result = (char *)malloc(totalSize);
            if (!result) {
                perror("Memory allocation failed");
                exit(EXIT_FAILURE);
            }
            result[0] = '\0';

            fn = entry->functions;
            while (fn) {
                strcat(result, ".");
                strcat(result, fn->function_name); 
                strcat(result, " = ");
                strcat(result, fn->function_name);
                strcat(result, ", ");
                fn = fn->next;
            }

            result[strlen(result) - 2] = '\0';

            return result;
        }
        entry = entry->next;
    }
    return strdup("");
}

//==========================================================================================================================
//==========================================================================================================================
// comp_type_variable: 

typedef struct compTypeVariable {
    char *variable_name;
    char *comp_name;
    struct compTypeVariable *next;
} compTypeVariable;

compTypeVariable *head = NULL;

void create_compTypeVariables(const char *comp_name, const char *variable_names) {
    char *var_names_copy = strdup(variable_names); // Create a mutable copy of the string
    if (!var_names_copy) {
        perror("Failed to allocate memory");
        exit(EXIT_FAILURE);
    }
    char *token = strtok(var_names_copy, ",");
    while (token) {
        while (*token == ' ') token++;
        char *end = token + strlen(token) - 1;
        while (end > token && (*end == ' ' || *end == '\n')) end--;
        *(end + 1) = '\0';
        compTypeVariable *new_entry = (compTypeVariable *)malloc(sizeof(compTypeVariable));
        if (!new_entry) {
            perror("Failed to allocate memory");
            exit(EXIT_FAILURE);
        }
        new_entry->variable_name = strdup(token); 
        new_entry->comp_name = strdup(comp_name); 
        new_entry->next = head;
        head = new_entry;
        token = strtok(NULL, ","); 
    }
    free(var_names_copy); 
}

char *find_comp_type(const char *variable_name) {
    compTypeVariable *current = head;

    while (current) {
        if (strcmp(current->variable_name, variable_name) == 0) {
            return current->comp_name;
        }
        current = current->next;
    }
    return NULL; // Not found
}

//==========================================================================================================================
//==========================================================================================================================
//==========================================================================================================================
//==========================================================================================================================
// Other Stuff:

int indentation_level = 0;

int assignment_made = 0;

char *temp1, *temp2, *temp3, *temp4, *temp5, *temp6, *temp7, *temp8, *temp9, *temp10, *temp11, *temp12;
char *indented_stmts, *indented_stmts_1, *indented_stmts_2, *indented_stmts_3, *indented_stmts_4, *indented_stmts_5;
char* comp_name;

char* indent_statements(const char* statements, int level) {
    int rrrr = 0;
    sstream S;
    ssopen(&S);
    if(level >= 1){
      level = 1;
    } 
    const char* current = statements;
    int is_new_line = 1;  

    while (*current != '\0') {
        if (is_new_line) {
            
            for (int i = 0; i < level; i++) {
                fprintf(S.stream, "  "); 
                rrrr++;
            }
            is_new_line = 0;  
        }
        fputc(*current, S.stream);
        if (*current == '\n') {
            is_new_line = 1;  
        }
        current++;
    }
    char* result = ssvalue(&S);
    ssclose(&S);
    return result;
}

//==========================================================================================================================
//==========================================================================================================================

  typedef struct {
      const char *original;
      const char *transformed;
  } TypeMapping;

  TypeMapping typeMappings[] = {
      {"KW_SCALAR", "double"},
      {"KW_INTEGER", "int"},
      {"KW_STR", "char*"},
      {"KW_BOOLEAN", "int"},
  };

//==========================================================================================================================

  char* transform_type(const char *identifier) {
      for (int i = 0; i < sizeof(typeMappings) / sizeof(typeMappings[0]); i++) {
          if (strcmp(identifier, typeMappings[i].original) == 0) {
              return (char*)typeMappings[i].transformed;
          }
      }
      return NULL; 
  }

//==========================================================================================================================

  char* handle_variable_type(const char *inputType) {
      return transform_type(inputType);
  }

  int is_a_loop = 0;

//==========================================================================================================================
// Strings:

char* replace_identifier_in_expr(const char* expr, const char* oldVar, const char* newVar) {
    char* result = strdup(expr); 
    char* pos = strstr(result, oldVar); 
    
    if (pos) {
        size_t newLen = strlen(newVar);
        size_t oldLen = strlen(oldVar);
        char* newExpr = (char*)malloc(strlen(result) + newLen - oldLen + 1);
        
        strncpy(newExpr, result, pos - result); 
        strcpy(newExpr + (pos - result), newVar); 
        strcat(newExpr, pos + oldLen); 
        
        free(result);
        return newExpr;
    }
    
    return result;
}

//==========================================================================================================================

int contains_substring(const char *s1, const char *s2) {
    if (strstr(s1, s2) != NULL) {
        return 1; 
    }
    return 0;  
}


//==========================================================================================================================
//==========================================================================================================================
//==========================================================================================================================

%}

%debug

%union
{
  char* str;
}

%token <str> IDENTIFIER POSINT STRING DECIMAL REAL
%token <str> KW_IF KW_ELSE KW_ENDIF KW_IN KW_OF 
%token <str> KW_WHILE KW_ENDWHILE KW_FOR KW_ENDFOR KW_BREAK KW_CONTINUE
%token <str> KW_TRUE KW_FALSE KW_VAR KW_INT KW_REAL KW_FUNC KW_BEGIN 
%token <str> KW_DEF KW_ENDDEF KW_COMP KW_ENDCOMP KW_MACRO
%token <str> KW_RETURN KW_MAIN KW_FUNC_RETURN
%token <str> KW_INTEGER KW_SCALAR KW_STR KW_CONST KW_BOOLEAN

%type <str> KW_VARIABLE_TYPE VALUE NUMBERS
%type <str> expr arithmetic_expr_non_empty variable_definition variable_definition_comp parameter_definition variable_list variable_list_comp declaration_comp
%type <str> function_definition body arguments return_type 
%type <str> func_call func_args 
%type <str> complicated_types function_definition_comp function_definition_section return_type_comp
%type <str> commands stmts else_statement step loop_thing
%type <str> macro input 

%start program


%right <str> EXPONENTIATION_OP 
%left <str> CALC_OP    
%right <str> UNARY_OP             
%left <str> RELATIONAL_OP    
%right <str> LOGICAL_NOT_OP       
%left <str> LOGICAL_AND_OR_OP     
%right <str> ASSIGNMENT_OP        

%right KW_PLUS
%right KW_MINUS
%left KW_MUL
%left KW_DIV
%left KW_MOD

%left KW_LESSEQUAL
%left KW_GREATEREQUAL
%left KW_LESSTHAN
%left KW_GREATHAN
%left KW_INEQ

%left KW_AND
%left KW_OR
%right KW_NOT

%left KW_EQUAL

%right KW_EXPONENT
%left ';' 
%precedence POSINT
%precedence IDENTIFIER
%precedence ')'
%precedence ']'
%precedence '('
%precedence '['
%right '#'

%%

//==============================================================================================================================================================
//==============================================================================================================================================================

program:
  input { print_evaluation($1); } 

input:  
    %empty                                        {$$ = "";} //@@@@@@@@@
//   | input func_call ';'                           { $$ = template("%s%s;\n", $1, $2); } 
  | input variable_definition ';'                 { $$ = template("%s%s\n", $1, $2);}
  | input expr ';'                                { assignment_made = 0;  $$ = template("%s%s;\n", $1, $2);}
  | input function_definition ';'                 { assignment_made = 0; $$ = template("%s%s", $1, $2);}
  | input complicated_types ';'                   { assignment_made = 0;  $$ = template("%s%s", $1, $2);} 
  | input commands ';'                            {  $$ = template("%s%s", $1, $2);} 
  | input macro                                   {  $$ = template("%s%s", $1, $2);} 
;

//==============================================================================================================================================================
// macros:

macro:
    KW_MACRO IDENTIFIER STRING {
        char *id = $2; 
        char *value = $3;
        
        add_macro(id, value);  

    }
  | KW_MACRO IDENTIFIER expr {
        char *id = $2;  
        char *value = $3; 

        add_macro(id, value);
    }
;


//==============================================================================================================================================================
// if-while-for:

commands:
    KW_IF '(' expr ')' ':' {temp1 = template("%s (%s):\n", $1, $3); indentation_level++; is_a_loop = 0;} 
    stmts 
    {
        indented_stmts = indent_statements($7, indentation_level);
        indentation_level--;
    }
    else_statement KW_ENDIF {
        temp3 = template("%s%s", $9, $10); 
        $$ = template("%s%s%s;\n", temp1, indented_stmts, temp3);
    }
    //==============================================================================================================================================================
    | KW_WHILE '(' expr ')' ':' 
    {
        temp7 = template("%s (%s):\n", $1, $3);
        indentation_level++; is_a_loop = 1;
    }
    stmts 
    {
        indented_stmts_3 = indent_statements($7, indentation_level);
        indentation_level--;
    }
    KW_ENDWHILE {
        $$ = template("%s%s%s;\n", temp7, indented_stmts_3, $9);
        is_a_loop = 0;
    }

    //==============================================================================================================================================================
    // for loop

    | KW_FOR IDENTIFIER KW_IN '[' arithmetic_expr_non_empty ':' arithmetic_expr_non_empty step ']' ':'
    {
        if(for_has_step == 1){
            temp5 = template("for (int %s = %s; %s < %s; %s++) {\n", $2, $5, $2, $7, $8, $2); 
        } else {
            temp5 = template("for (int %s = %s; %s < %s; %s++) {\n", $2, $5, $2, $7, $2); 
        }
         
        indentation_level++; is_a_loop = 1;
    }
    stmts 
    {
        indented_stmts_2 = indent_statements($12, indentation_level);
        indentation_level--;
    }
    KW_ENDFOR {

        $$ = template("%s%s}\n", temp5, indented_stmts_2);
        is_a_loop = 0;
    }

    //==============================================================================================================================================================
    // Malloc:

    | IDENTIFIER ASSIGNMENT_OP '[' expr KW_FOR IDENTIFIER ':' POSINT ']' ':' KW_VARIABLE_TYPE  
    {
        char* newType = $11;
        if (contains_substring($4,$6) == 0){
            yyerror("In compact array, the element isnt contained in the expression"); 

        }
        $$ = template("%s* %s =(%s*)malloc(%s*sizeof(%s));\nfor (int %s = 0; %s < %s; ++%s) {\n  %s[%s] = %s;\n}\n", 
                        newType, $1,newType,$8,     newType,        $6,     $6,  $8,  $6,       $1,$6,   $4);

    }
    //==============================================================================================================================================================
    // Malloc with In Keyword: 

    | IDENTIFIER ASSIGNMENT_OP '[' expr KW_FOR IDENTIFIER ':' KW_VARIABLE_TYPE KW_IN IDENTIFIER KW_OF POSINT ']' ':' KW_VARIABLE_TYPE
    {
        char* newType = $15; 
        char* s2 = template("%s[%s_i]",$10,$10);
        if (contains_substring($4,$6) == 0){
            yyerror("In compact array, the element isnt contained in the expression"); 

        }

        char* modifiedExpr = replace_identifier_in_expr($4, $6, s2);


        $$ = template(
            "%s* %s = (%s*)malloc(%s * sizeof(%s));\nfor (%s %s_i = 0; %s_i < %s; ++%s_i) {\n   %s[%s_i] = %s;\n}\n",
            newType,$1, newType, $12, newType,            $8, $10,      $10, $12,    $10,    $1, $10, modifiedExpr
        );
    }
    ;

//==============================================================================================================================================================
// Else: 

else_statement:
    %empty                                           { $$ = ""; }
  | KW_ELSE ':'                       {temp4 = template("%s:\n", $1); indentation_level++;}
  stmts 
  {         
      indented_stmts_1 = indent_statements($4, indentation_level);
      indentation_level--;
       $$ = template("%s%s", temp4, indented_stmts_1);
  }

step:
    %empty                              { for_has_step = 0; $$ = ""; }
  | ':' arithmetic_expr_non_empty       { for_has_step = 1; $$ = template(":%s", $2);}
;


//==============================================================================================================================================================
// Statement:

stmts:
    %empty                                        { $$ = ""; }
  | stmts loop_thing ';'                           
  {     
    if (is_a_loop != 1) {  
      yyerror("This isnt a loop"); 
      YYABORT;
    }
    $$ = template("%s%s;\n", $1, $2);} 
  | stmts variable_definition ';'                 { $$ = template("%s%s\n", $1, $2); }
  | stmts expr ';'                                
  { 
    assignment_made = 0; 
    $$ = template("%s%s;\n", $1, $2); 
  }
  | stmts commands ';'                            { $$ = template("%s%s", $1, $2); } 

loop_thing:
  KW_BREAK|KW_CONTINUE;

//==============================================================================================================================================================
//==============================================================================================================================================================
//==============================================================================================================================================================
// Comp: 

complicated_types:

  KW_COMP IDENTIFIER { comp_name = $2; inside_comp = 1; createNewComp(comp_name);}
  ':' declaration_comp function_definition_section KW_ENDCOMP 
  { 
    char* function_definition_prints = getCompFunctionsAsString(comp_name);   
    char* function_names = getCompFunctionNamesAsString(comp_name);
    $$ = template("typedef struct %s {\n%s%s} %s;\n%s\n%s ctor_%s = {%s};\n", $2, $5, $6, comp_name, function_definition_prints, comp_name, comp_name, function_names); 

    inside_comp = 0;
  }

//==============================================================================================================================================================
// declaration_variables_comp:

declaration_comp:
    %empty                                                  { $$ = ""; }  
  | declaration_comp variable_definition_comp ';'           { $$ = template("%s  %s;\n", $1, $2); }
;

variable_definition_comp:
    variable_list_comp ':' KW_VARIABLE_TYPE                                     { if(is_comp_type($3)){ create_compTypeVariables($3, $1);} add_comp_variables(comp_name, $1);
                                                                                  $$ = template("%s %s", $3, $1);}
  | '#' IDENTIFIER '[' POSINT ']' ':' KW_VARIABLE_TYPE                          { if(is_comp_type($7)){create_compTypeVariables($7, $2);} add_comp_variable(comp_name, $2); 
                                                                                  $$ = template("%s %s[%s];", $7, $2, $4 ); }       
  | '#' IDENTIFIER '[' ']' ':' KW_VARIABLE_TYPE                                 { if(is_comp_type($6)){create_compTypeVariables($6, $2);} add_comp_variable(comp_name, $2);
                                                                                  $$ = template("%s[]: %s;", $2, $6 ); }
  | '#' KW_CONST IDENTIFIER ASSIGNMENT_OP VALUE ':' KW_VARIABLE_TYPE            { if(is_comp_type($7)){create_compTypeVariables($7, $3);} add_comp_variable(comp_name, $3);
                                                                                  $$ = template("%s %s %s = %s;", $2, $7, $3, $5); }
;

variable_list_comp:
  '#' IDENTIFIER                                    { $$ = template("%s", $2); }
  | variable_list_comp ',' '#' IDENTIFIER           { $$ = template("%s, %s", $1, $4); }
;

//==============================================================================================================================================================
// function_comp:


function_definition_section:
    %empty                                                      { $$ = "\n"; }  
 | function_definition_section function_definition_comp ';'     {$$ = template("%s  %s;\n", $1, $2);}
;

function_definition_comp:
  KW_DEF IDENTIFIER '(' arguments ')' return_type_comp ':' body KW_ENDDEF
  {
    if (func_needs_return_type != body_has_return_type) {  
      yyerror("Return statement missing from body"); 
      YYABORT;
    }
    $$ = template("%s (*%s)(struct %s *self%s%s)", $6, $2, comp_name, strlen($4) ? ", " : "", $4);
    func_needs_return_type = 0;
    body_has_return_type = 0;

    add_function($2, num_of_args_in_function);  
    num_of_args_in_function = 0;
    char* function_follow_comp = template("%s %s(struct %s *self%s%s) {\n%s\n}", $6, $2, comp_name,strlen($4) == 0 ? "":", " , $4, $8 );
    addFunctionToComp(comp_name, function_follow_comp, $2);
  }
;

return_type_comp:
   %empty                               { $$ = "void"; } 
 | KW_FUNC_RETURN KW_VARIABLE_TYPE      { func_needs_return_type = 1; $$ = template("%s", $2); }
;

//==============================================================================================================================================================
// function call:

func_call:

    IDENTIFIER '(' func_args ')' 
    {  
        const DefinedFunction* func = find_function($1);
        function_name_temp = $1;

        if(find_included_function($1) == 1) {used_lambdalib_function = 1;}

        if (!func || (func->has_arguments != 99 && num_of_args_in_function_in_func_call != func->has_arguments && func->has_arguments != 999)) {
            yyerror("Wrong function call or function hasn't been defined"); YYABORT;

        } else {
            $$ = template("%s(%s)", $1, $3);
        }
        num_of_args_in_function_in_func_call = 0;
    }
;

func_args:
    %empty { $$ = ""; } 
  | expr                            { num_of_args_in_function_in_func_call++; $$ = template("%s", $1); }
  | STRING                          { num_of_args_in_function_in_func_call++; $$ = template("%s", $1); }
  | func_args ',' expr              { num_of_args_in_function_in_func_call++; $$ = template("%s, %s", $1, $3); }
  | func_args ',' STRING            { num_of_args_in_function_in_func_call++; $$ = template("%s, %s", $1, $3); }
;

//==============================================================================================================================================================
// expressions:

expr:
    // %empty                           { $$ = ""; } // @@@@@@@@@
    func_call                           { $$ = template("%s", $1);  } 
  | NUMBERS                             { $$ = $1; }
  |'#' IDENTIFIER                       { if (inside_comp == 0 || !(is_comp_variable(comp_name, $2))) {yyerror("Variable, not in comp"); YYABORT;} 
                                          else { $$ = template("self->%s", $2);} }
  |'#' IDENTIFIER '[' expr ']'          { if (inside_comp == 0 || !(is_comp_variable(comp_name, $2))) {yyerror("Variable, not in comp"); YYABORT;} 
                                          else { $$ = template("self->%s[%s]", $2, $4);} }
  | IDENTIFIER                          { $$ = $1; }
  | IDENTIFIER '[' expr ']'             { $$ = template("%s[%s]", $1, $3); }
  | '(' expr ')'                        { $$ = template("(%s)", $2); }
  | expr CALC_OP expr                   { $$ = template("%s %s %s", $1, $2, $3); }  
  | expr EXPONENTIATION_OP expr         { $$ = template("pow(%s, %s)", $1, $3); } 
  | expr RELATIONAL_OP expr             { $$ = template("%s %s %s", $1, $2, $3); }  
  | expr LOGICAL_AND_OR_OP expr         { $$ = template("%s %s %s", $1, $2, $3); }  
  | LOGICAL_NOT_OP expr                 { $$ = template("%s %s", $1, $2); }  
  | UNARY_OP expr                       { $$ = template("%s%s", $1, $2); }  
  | IDENTIFIER ASSIGNMENT_OP expr        
  {
      if (assignment_made == 1) {
          yyerror("Multiple assignments in one expression are not allowed");
          YYABORT; 
      }
      assignment_made = 1; 
      $$ = template("%s %s %s", $1, $2, $3); 
  }
  | IDENTIFIER '[' expr ']'  ASSIGNMENT_OP expr     
  {
      if (assignment_made == 1) {
          yyerror("Multiple assignments in one expression are not allowed");
          YYABORT; 
      }
      assignment_made = 1; 
      $$ = template("%s[%s] %s %s", $1, $3, $5, $6 ); 
  }
  | '#' IDENTIFIER ASSIGNMENT_OP expr     
  {     
      if (assignment_made == 1 || inside_comp == 0) {
          yyerror("Multiple assignments in one expression are not allowed or not in comp");
          YYABORT; 
      }
      assignment_made = 1; 
      $$ = template("self->%s %s %s", $2, $3, $4); 
  }
  | '#' IDENTIFIER '[' expr ']'  ASSIGNMENT_OP expr       
  {
      if (assignment_made == 1 || inside_comp == 0) {
          yyerror("Multiple assignments in one expression are not allowed or not in comp");
          YYABORT; 
      }
      assignment_made = 1; 
      $$ = template("self->%s[%s] %s %s", $2, $4, $6, $7 ); 
  }
  | '#' IDENTIFIER '.' func_call  
  {     
      char* comp_name = find_comp_type($2);

      if(is_comp_function(comp_name, function_name_temp) == 0){
          yyerror("Function used isnt assigned for this variable type");
          YYABORT; 
      }
      $$ = template("self->%s.%s", $2, $4); 

  }
  | '#' IDENTIFIER '[' expr ']' '.' func_call  
  {     
      char* comp_name = find_comp_type($2);

      if(is_comp_function(comp_name, function_name_temp) == 0){
          yyerror("Function used isnt assigned for this variable type");
          YYABORT; 
      }
      $$ = template("self->%s[%s].%s", $2, $4, $7); 

  }
;

arithmetic_expr_non_empty:
    POSINT                              { $$ = $1; }
  | REAL                                { $$ = $1; }
  | IDENTIFIER                          { $$ = $1; }
  | '#' IDENTIFIER                      { if(inside_comp == 0){yyerror("Not allowed outside comp");YYABORT;} $$ = $2; }
  | '(' expr ')'                        { $$ = template("(%s)", $2); }
  | expr EXPONENTIATION_OP expr         { $$ = template("pow(%s, %s)", $1, $3); }
  | expr CALC_OP expr                   { $$ = template("%s %s %s", $1, $2, $3); }
  | expr RELATIONAL_OP expr             { $$ = template("%s %s %s", $1, $2, $3); }
  | expr LOGICAL_AND_OR_OP expr         { $$ = template("%s %s %s", $1, $2, $3); }
  | LOGICAL_NOT_OP expr                 { $$ = template("%s %s", $1, $2); }
  | UNARY_OP expr                       { $$ = template("%s%s", $1, $2); }
;

//==============================================================================================================================================================
// Function Definition Main:

function_definition:

  KW_DEF KW_MAIN'('')' ':'  
{
    indentation_level++;
    temp8 = template("void %s() {\n", $2);
}
  body 
{      
    indented_stmts_4 = indent_statements($7, indentation_level);
    indentation_level--;
}
  KW_ENDDEF
{     
    if (func_needs_return_type != body_has_return_type) {  
      yyerror("Return statement missing from body"); 
      YYABORT;
    }
    $$ = template("%s%s}\n", temp8, indented_stmts_4);
}
;


//============================================================================================================================================
// Function Definition:

| KW_DEF IDENTIFIER'(' arguments ')' return_type ':'  
{
    add_function($2, num_of_args_in_function);  
    num_of_args_in_function = 0;
    indentation_level++;
    temp8 = template("%s %s(%s){\n", $6, $2, $4 );
}
  body 
{      
    indented_stmts_4 = indent_statements($9, indentation_level);
    indentation_level--;
}
  KW_ENDDEF
{     
    if (func_needs_return_type != body_has_return_type) {  
      yyerror("Return statement missing from body"); 
      YYABORT;
    }
    $$ = template("%s%s}\n", temp8, indented_stmts_4);
    func_needs_return_type = 0;
    body_has_return_type = 0;

}
;

// Arguments of a function:

arguments: 
    %empty { $$ = ""; } 
  | parameter_definition                { num_of_args_in_function++; $$ = template("%s", $1); }             // int n, int k
  | arguments ',' parameter_definition  { num_of_args_in_function++; $$ = template("%s, %s", $1, $3); }
;

parameter_definition:  
   IDENTIFIER ':' KW_VARIABLE_TYPE                              { $$ = template("%s %s", $3, $1); }            
 | IDENTIFIER '[' POSINT ']' ':' KW_VARIABLE_TYPE               { $$ = template("%s[%s]: %s", $1, $3, $6 ); }   
 | IDENTIFIER '[' ']' ':' KW_VARIABLE_TYPE                      { $$ = template("%s[]: %s", $1, $5 ); }
; 

return_type:
   %empty { $$ = ""; } 
 | KW_FUNC_RETURN KW_VARIABLE_TYPE { func_needs_return_type = 1; $$ = template("%s", $2); }
;

body: 
  stmts                     { body_has_return_type = 0; $$ = template("%s", $1); }
| stmts KW_RETURN expr ';'  { body_has_return_type = 1; $$ = template("%s%s %s;\n", $1, $2 , $3); }
;


//==============================================================================================================================================================
// Variable Definition: 

variable_definition:  
   variable_list ':' KW_VARIABLE_TYPE          // a, b: integer; => int a, b;            
   {  
        if(is_comp_type($3)){
            create_compTypeVariables($3, $1);
            $$ = template("%s %s = ctor_%s;", $3, $1, $3);        
        } else { $$ = template("%s %s;", $3, $1); }   
   }             
 | IDENTIFIER '[' POSINT ']' ':' KW_VARIABLE_TYPE                       { $$ = template("%s %s[%s];", $6, $1, $3 ); }       // grades[5]: scalar; => double grades[5];
 | IDENTIFIER '[' ']' ':' KW_VARIABLE_TYPE                              { $$ = template("%s[]: %s;", $1, $5 ); }
 | KW_CONST IDENTIFIER ASSIGNMENT_OP VALUE ':' KW_VARIABLE_TYPE         { $$ = template("%s %s %s = %s;", $1, $6, $2, $4); }
; 

VALUE:
    POSINT 
  | REAL
  | STRING
;

KW_VARIABLE_TYPE:
    KW_SCALAR 
  | KW_INTEGER          {$$ = $1; }
  | KW_STR 
  | KW_BOOLEAN
  | IDENTIFIER {
    if (is_comp_type($1)) {
        $$ = template("%s", $1);
    } else {
        yyerror("Unknown variable type");
        YYABORT;
    }
  }
;

NUMBERS:
    POSINT
  | REAL
;

variable_list:
    IDENTIFIER                      { $$ = template("%s", $1); }
  | variable_list ',' IDENTIFIER    { $$ = template("%s, %s", $1, $3); }
;

//==============================================================================================================================================================
//==============================================================================================================================================================

%%
    void print_evaluation(char* result) {

        if (yyerror_count == 0) {
            printf("===================================================== Expression evaluates to =====================================================\n%s\n", result);
            
            FILE *file = fopen("output.c", "w");
            if (file != NULL) {
                
                fprintf(file, "#include <stdio.h>\n");
                fprintf(file, "#include <stdlib.h>\n");  
                fprintf(file, "#include <math.h>\n");

                if(used_lambdalib_function == 1){
                    fprintf(file, "#include \"lambdalib.h\"\n");
                }
                
                fprintf(file, "%s\n", result);
                fclose(file);
            } else {
                fprintf(stderr, "Error opening output.c for writing.\n");
            }
        }
    }

//==============================================================================================================================================================

bool is_integer(const char* str) {
    if (str == NULL || *str == '\0') return false;
    if (*str == '-' || *str == '+') {
        str++;
    }
    while (*str) {
        if (!isdigit((unsigned char)*str)) {
            return false;
        }
        str++;
    }
    return true;
}

//==============================================================================================================================================================
//==============================================================================================================================================================

int main () {

    char buffer[BUFFER_SIZE];  
    //  yydebug = 1; // Enable debug output

    // initialize_predefined_functions();
    include_functions();
    
    FILE *file = fopen("test1.in", "r");
    if (file == NULL) {
        perror("Could not open file");
        return 1;
    }

    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        store_line(buffer);
    }

    if (yyparse() == 0 && parse_error == 0) {
        printf("Your program is syntactically correct!\n");
    } else {
        printf("Rejected\n");
    }

    free_functions();
    free_lines();


    return 0;
}